## 中心扩展法求最长回文子串

**问题描述：** 给定一个字符串 `s`，找到其中的最长回文子串。

**算法思路：**

1. 初始化起始位置 `start` 为 0，最大长度 `maxLength` 为 0。
2. 遍历字符串 `s`，以每个字符为中心点向两边扩展寻找回文子串。
   - 对于奇数长度的回文子串，以当前字符为中心，从左右两个指针开始向外扩展，比较左右字符是否相等，直到左右指针越界或字符不相等。
   - 对于偶数长度的回文子串，以当前字符和下一个字符的间隙为中心，从左右两个指针开始向外扩展，比较左右字符是否相等，直到左右指针越界或字符不相等。
3. 在扩展过程中记录最长回文子串的起始位置和长度。
4. 返回最长回文子串。

**Java 代码实现：**

```java
public String longestPalindrome(String s) {
    int len = s.length();
    int start = 0;
    int maxLength = 0;

    for (int i = 0; i < len; i++) {
        int len1 = expandAroundCenter(s, i, i);      // 奇数长度的回文子串
        int len2 = expandAroundCenter(s, i, i + 1);  // 偶数长度的回文子串
        int currLen = Math.max(len1, len2);

        if (currLen > maxLength) {
            maxLength = currLen;
            start = i - (currLen - 1) / 2;
        }
    }

    return s.substring(start, start + maxLength);
}

private int expandAroundCenter(String s, int left, int right) {
    int len = s.length();
    while (left >= 0 && right < len && s.charAt(left) == s.charAt(right)) {
        left--;
        right++;
    }
    return right - left - 1;  // 返回回文子串的长度
}
```

**算法分析：**

- 时间复杂度：该算法的时间复杂度为 O(n^2)，其中 n 是字符串的长度。

- 空间复杂度：该算法的空间复杂度为 O(1)，没有使用额外的空间。

该中心扩展法算法通过从每个字符为中心点向两边扩展的方式，能够快速找到最长回文子串。相较于暴力枚举所有子串的方法，该算法具有更好的时间效率。