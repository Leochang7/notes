## PX4 GAZEBO MAVROS协同工作

| 组件         | 核心角色             | 功能简述                                |
| ---------- | ---------------- | ----------------------------------- |
| **PX4**    | **大脑 (Brain)**   | 运行飞行/运动控制算法，进行状态估计，执行自主任务。          |
| **Gazebo** | **虚拟世界 (World)** | 提供物理引擎、三维场景和传感器数据模拟。                |
| **MAVROS** | **桥梁 (Bridge)**  | 实现 PX4 (MAVLink) 与 ROS 生态系统之间的双向通信。 |
这三者之间的协作关系可以概括为：**Gazebo 创造虚拟环境和物理模型，PX4 在其中作为“虚拟大脑”进行控制，而 MAVROS 则负责打通 PX4 与上层应用（通常在 ROS 中开发）之间的通信。**
具体的协同工作流程如下：
1. **启动仿真环境**: 首先，你在 Gazebo 中加载一个包含无人机、无人车或无人船模型的世界。这个模型不仅仅是一个外观，它还包含了质量、惯性、传感器插件等物理属性。
2. **物理模拟与传感器数据生成**: Gazebo 的物理引擎会根据模型的物理属性和控制指令来模拟其运动。同时，模型上附加的传感器插件（如 IMU、气压计、GPS 插件）会根据当前的状态生成模拟的传感器数据。
3. **数据流向 PX4**: Gazebo 将模拟产生的传感器数据发送给正在运行的 PX4 SITL 实例。对于 PX4 来说，它无法分辨这些数据是来自真实的物理传感器还是来自 Gazebo 的模拟器，因此会像在真实硬件上一样处理这些数据。
4. **PX4 的决策与控制**: PX4 的状态估计模块会融合这些模拟的传感器数据，计算出无人系统的当前姿态、位置、速度等状态。然后，其控制器会根据预设的模式（如位置控制、任务执行）或外部指令，计算出期望的电机/舵机输出。
5. **控制指令流回 Gazebo**: PX4 将计算出的控制指令（例如，给每个旋翼的转速）发送回 Gazebo。
6. **Gazebo 更新模型状态**: Gazebo 接收到这些控制指令后，会将其施加到虚拟模型上，从而更新模型在下一个仿真步长中的状态，形成一个闭环控制。
7. **MAVROS 的桥梁作用**: 在整个过程中，MAVROS 一直在后台运行。
    - **下行通信**: 开发者可以通过 ROS 发布指令（例如，发布一个目标航点到 /mavros/setpoint_position/local 话题），MAVROS 会接收到这个 ROS 消息，将其转换为 MAVLink 协议的指令，然后发送给 PX4。这使得你可以用自己的 ROS 节点来编写复杂的上层控制算法。
    - **上行通信**: MAVROS 会持续地从 PX4 获取各种状态信息（如无人系统的位置、姿态、电池电压等），并将这些 MAVLink 消息转换为 ROS 话题（如 /mavros/local_position/pose）发布出来。这使得你可以方便地在 ROS 中订阅这些信息，用于监控、数据记录或进一步的算法处理。
## 怎么控制
用代码控制仿真的无人系统，核心就是**编写一个 ROS 节点**，通过 MAVROS 与 PX4 进行通信
控制的本质是
1. **订阅 (Subscribe)**：从 MAVROS 获取无人系统的状态信息（如：是否连接？当前是什么模式？位置在哪里？）。
2. **发布 (Publish)**：向 MAVROS 发送你的控制指令（如：我希望无人机飞到坐标 (x, y, z)）。
3. **调用服务 (Service Call)**：向 MAVROS 请求执行某些一次性的动作（如：解锁无人机！切换到“OFFBOARD”模式！）。

因此，一个典型的控制流程（尤其是起飞）遵循一个固定的“仪式”：
1. 启动你的控制节点。
2. 等待 MAVROS 与 PX4 飞控成功连接。
3. 在请求切换到 OFFBOARD 模式**之前**，你必须先开始发送位置指令流。
4. 当确认指令流已经开始后，向 MAVROS 发送服务请求，要求将模式切换为 “OFFBOARD”。
5. 在切换成功后，再发送服务请求，要求 “解锁 (Arm)” 无人机。
6. 解锁成功后，无人机就会执行你发布的指令（例如，飞向你设定的目标点）。

### **代码控制要点总结**

|            |           |                                 |                                                        |
| ---------- | --------- | ------------------------------- | ------------------------------------------------------ |
| 动作         | 方式        | 对应的 MAVROS 接口 (Topic/Service)   | 示例代码中的实现                                               |
| **获取状态**   | 订阅Topic   | /mavros/state                   | rospy.Subscriber("mavros/state", State, ...)           |
| **发送位置目标** | 发布Topic   | /mavros/setpoint_position/local | rospy.Publisher("mavros/setpoint_position/local", ...) |
| **切换模式**   | 调用Service | /mavros/set_mode                | rospy.ServiceProxy("mavros/set_mode", SetMode)         |
| **解锁/上锁**  | 调用Service | /mavros/cmd/arming              | rospy.ServiceProxy("mavros/cmd/arming", CommandBool)   |

### **扩展到无人车和无人船**

这个逻辑对于无人车 (Rover) 和无人船 (Boat) 是完全一样的。主要区别在于：

1. **启动的PX4固件不同**：你可能需要启动 make px4_sitl gazebo_rover 或类似的命令。
2. **控制的自由度不同**：对于地面车辆，你通常只控制 (x, y) 位置和朝向，z 坐标是固定的。对于无人船也是类似。你只需要修改 self.pose 变量中的目标值即可。
3. **MAVROS 的 Topic 可能有细微差别**，但核心的 /mavros/state, /mavros/setpoint_position/local, /mavros/cmd/arming, /mavros/set_mode 都是通用的。

掌握了这个基本的代码控制框架，你就可以开始集成更复杂的算法，比如路径规划、目标跟踪、视觉伺服等。你只需要在主循环中，根据你算法的输出，动态地修改 self.pose 的值，就可以控制无人系统去执行各种复杂的任务了。

### **常用 MAVROS Topics (话题)**

Topics 用于**连续的数据流**。你可以**订阅 (Subscribe)** 它们来获取信息，或者**发布 (Publish)** 到它们上面来发送连续的指令。
#### **核心状态与位置信息 (最常用，必须掌握)**

|                                       |                            |                                                                             |
| ------------------------------------- | -------------------------- | --------------------------------------------------------------------------- |
| 接口 (Topic)                            | 消息类型 (Message Type)        | 功能描述                                                                        |
| /mavros/state                         | mavros_msgs/State          | **最重要的Topic**。提供飞控的连接状态 (connected)、解锁状态 (armed)、飞行模式 (mode) 等。你的代码必须先检查这个。 |
| /mavros/local_position/pose           | geometry_msgs/PoseStamped  | 无人机在本地坐标系 (通常是起飞点为原点的ENU或NED坐标系) 下的位置和姿态。这是进行位置控制时最主要的反馈来源。                 |
| /mavros/local_position/velocity_local | geometry_msgs/TwistStamped | 无人机在本地坐标系下的线速度和角速度。                                                         |
| /mavros/global_position/global        | sensor_msgs/NavSatFix      | 全局GPS位置信息 (经度、纬度、海拔)。                                                       |
| /mavros/battery                       | sensor_msgs/BatteryState   | 电池电压、剩余电量百分比等。对于真实飞行和长时间仿真非常重要。                                             |
**目标位置是一个相对位置。** 这是一个极其关键且需要牢牢记住的概念。

当你向 /mavros/setpoint_position/local 发送一个位置指令 (x, y, z) 时，这个坐标**不是**：

- 不是一个绝对的GPS经纬度。
- 不是相对于无人机当前位置的增量（比如“在现在的位置上再向前飞1米”）。
- 不是相对于某个固定信标的位置。

它**是**相对于一个**固定的、在任务开始时就已确立的原点**的位置。这个原点就是我们之前讨论的**本地坐标系 (map 帧) 的原点 (0,0,0)**。
#### **设定点/控制指令 (用于发送控制命令)**

|   |   |   |
|---|---|---|
|接口 (Topic)|消息类型 (Message Type)|功能描述|
|/mavros/setpoint_position/local|geometry_msgs/PoseStamped|**OFFBOARD模式下的位置控制**。向此Topic发布一个 PoseStamped 消息，无人机就会飞向你指定的位置和姿态。|
|/mavros/setpoint_velocity/cmd_vel_unstamped|geometry_msgs/Twist|**OFFBOARD模式下的速度控制**。向此Topic发布一个 Twist 消息，可以控制无人机的线速度和角速度。常用于键盘或手柄遥控。|
|/mavros/setpoint_raw/local|mavros_msgs/PositionTarget|更底层的控制接口，可以同时指定位置、速度、加速度、偏航角和偏航角速率。功能强大但使用更复杂。|
|/mavros/setpoint_attitude/cmd_vel|geometry_msgs/TwistStamped|直接控制姿态角速率和油门，绕过了PX4内部的位置控制器。属于高级控制。|

#### **原始传感器数据**

|   |   |   |
|---|---|---|
|接口 (Topic)|消息类型 (Message Type)|功能描述|
|/mavros/imu/data|sensor_msgs/Imu|IMU (惯性测量单元) 的原始数据，包括角速度和线性加速度。|
|/mavros/imu/mag|sensor_msgs/MagneticField|磁力计数据。|
|/mavros/imu/atm_pressure|sensor_msgs/FluidPressure|气压计数据。|

---

### **常用 MAVROS Services (服务)**

Services 用于**一次性的请求/响应**操作。你**调用 (Call)** 一个服务，并等待它返回一个结果。

#### **核心动作与模式切换 (最常用，必须掌握)**

|   |   |   |
|---|---|---|
|接口 (Service)|服务类型 (Service Type)|功能描述|
|/mavros/cmd/arming|mavros_msgs/CommandBool|**请求解锁 (Arm) 或上锁 (Disarm) 无人机**。请求的 value 字段为 true 表示解锁，false 表示上锁。|
|/mavros/set_mode|mavros_msgs/SetMode|**请求切换飞行模式**。通过设置 custom_mode 字段的字符串 (如 'OFFBOARD', 'AUTO.LAND', 'POSCTL') 来改变模式。|

#### **任务与命令**

|   |   |   |
|---|---|---|
|接口 (Service)|服务类型 (Service Type)|功能描述|
|/mavros/cmd/takeoff|mavros_msgs/CommandTOL|请求自主起飞。可以指定起飞高度。|
|/mavros/cmd/land|mavros_msgs/CommandTOL|请求自主降落。可以指定降落位置。|
|/mavros/mission/push|mavros_msgs/WaypointPush|上传一个航点任务 (mission) 到飞控。|
|/mavros/mission/pull|mavros_msgs/WaypointPull|从飞控下载当前的航点任务。|
|/mavros/mission/clear|mavros_msgs/WaypointClear|清除飞控中的所有航点。|

### 实现目标识别和跟踪目标
### **核心系统架构**

要实现目标识别与跟踪，我们的系统需要至少包含三个自定义的ROS节点（或一个更复杂的节点），它们协同工作：

1. **仿真环境 (Gazebo + PX4)**：提供一个带摄像头的无人机和一个可供识别的目标物体。
2. **视觉节点 (Vision Node)**：处理来自无人机摄像头的图像流，识别出目标，并计算出目标在图像中的位置。
3. **控制节点 (Control Node)**：接收视觉节点发来的目标位置信息，计算出控制指令（例如，“向左平移”、“向前飞”），然后通过 MAVROS 发送给 PX4，从而控制无人机跟踪目标。

---


1. **图像流**：Gazebo中的摄像头插件将模拟的图像发布到一个ROS Topic上 (例如 /camera/image_raw)。
2. **目标位置**：视觉节点订阅图像流，进行处理。一旦发现目标，它会将目标的位置信息（例如，在图像中的像素坐标(x,y)和边界框大小(w,h)）发布到另一个自定义的Topic上 (例如 /target_detector/target_pose)。
3. **控制指令**：控制节点订阅目标位置信息。根据目标在图像中的位置，它会计算出一个控制量（例如，速度指令），目标是让目标始终保持在图像的中心。
4. **MAVROS指令**：控制节点将计算出的速度指令发布到MAVROS的Topic上 (例如 /mavros/setpoint_velocity/cmd_vel_unstamped)。
5. **MAVLink指令**：MAVROS将ROS指令转换为MAVLink协议，发送给PX4。
6. **物理更新**：PX4执行指令，控制虚拟无人机的电机，Gazebo更新无人机的物理状态，这个闭环就完成了。

## PX4和gazebo写代码区别

|              |                                                                                                         |                                                                   |
| ------------ | ------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------- |
| 特性 (Feature) | 在 PX4-Autopilot 仓库中写代码                                                                                  | 在 Catkin Workspace (catkin_ws) 中写代码                               |
| **角色/目的**    | **固件开发 (Firmware Development)**                                                                         | **应用开发 (Application Development)**                                |
| **抽象层级**     | **低层 (Low-Level)**：直接与硬件、传感器和电机交互。                                                                      | **高层 (High-Level)**：通过MAVROS与飞控进行抽象化的通信。                          |
| **主要语言**     | **C++** (对性能和实时性有极高要求)                                                                                  | **Python** (用于快速原型和逻辑) / **C++** (用于性能密集型任务如图像处理)                 |
| **代码运行位置**   | **飞控硬件本身** (如 Pixhawk, Holybro Durandal)                                                                | **机载伴侣计算机 (Companion Computer)** (如 树莓派, Jetson Nano, NUC)        |
| **核心职责**     | - 姿态控制（PID环）、姿态估计（EKF）<br>- 飞行模式（Stabilized, Position, Mission）<br>- 传感器驱动（IMU, GPS, Baro）<br>- 电机混控与输出 | - 计算机视觉（目标识别、跟踪）<br>- 路径规划、运动规划<br>- 自主决策与任务逻辑<br>- 与地面站或云端进行高级通信 |
| **构建系统**     | **Make / CMake** (PX4自定义的编译系统)                                                                          | **Catkin** (catkin_make 或 catkin build)                           |
| **与另一方的通信**  | 通过 **MAVLink协议** 向外发送状态，接收指令                                                                            | 通过 **MAVROS节点** 将ROS话题和服务转换为MAVLink协议，与PX4通信                      |

基本不需要在PX4中写代码

## 整个流程

整个无人机的代码分在PX4里面写代码和在ROS里面写代码
PX4里面就是一些比较底层的代码，如果是支持的硬件像imu、电机这种我们基本不用写，即插即用
我们主要是写ROS的代码

第一步，我们需要在我们的工作空间catkin_ws创建一个功能包并引入相关的依赖包括rospy(ros的python接口),roscpp(ros的c++接口)，还有一些消息类型

第二步，接下来我们就可以在功能包里写c++代码和python代码
写代码引入对应的依赖之后，我们要做的就是订阅和发布主题 以及调用服务

订阅/mavros/state这个主题可以获取无人机的状态，包括飞控的连接状态 (connected)、解锁状态 (armed)、飞行模式 (mode) 等

检查完飞控已连接之后我们就可以发送目标位置到/mavros/setpoint_position/local这个主题

之后调用服务/mavros/set_mode设定模式是offboard也就是自动模式
最后调用/mavros/cmd/arming解锁无人机，无人机就会飞到对应位置

第三步，编写launch文件

launch文件是ROS同时启动和配置多个节点的工具，用roslaunch命令来启动launch文件
在仿真中我们要在launch中写px4仿真节点 gazebo节点 MAVROS节点 还有我们自己的控制节点
如果要实现目标识别还要增加一个视觉节点

launch文件里我们可以对gazebo的地图 模型进行设置，模型是sdf文件，我们可以自定义一个无人机模型，就比如在做目标识别时我使用的模型是带双目摄像头的四轴无人机，摄像头在无人机的前面看不到地面的图像，那我们就可以修改sdf文件，在无人机下面增加一个摄像头

在launch里面写节点不涉及具体的逻辑实现，只是为了批量启动节点，比如说一个python文件就算一个结点 结点直接也是通过话题通信的

第四步，编译与运行
在catkin_ws的工作空间进行编译，
接下来用roslaunch启动launch，这样就启动完成




