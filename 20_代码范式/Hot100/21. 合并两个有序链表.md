### 思路
先拿其中一个链表的头节点做新链表的头节点。然后用两个指针指两个旧链表进行比较，较小的插入新链表，会有一个链表先辈删完。把还有节点的链表全部插入新链表就可以了。比较不喜欢的点是Leetcode的代码全是默认不带头节点的（指第一个节点都带数据），这样合并不方便。
### 解法一：迭代
```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 == null) return list2;
        if (list2 == null) return list1;

        ListNode head;
        if (list1.val <= list2.val) {
            head = list1;
            list1 = list1.next;
        } else {
            head = list2;
            list2 = list2.next;
        }

        ListNode cur = head;

        while (list1 != null && list2 != null) {
            if (list1.val <= list2.val) {
                cur.next = list1;
                list1 = list1.next;
            } else {
                cur.next = list2;
                list2 = list2.next;
            }
            cur = cur.next;
        }

        cur.next = (list1 != null) ? list1 : list2;
        return head;
    }
}
```
#### 注意的点
1. 头节点有数据要先处理
2. 两个链表同时不为空，因为下面有比较
3. 递归的写法后面我再写留个空
### 解法二：递归