### 思路
这题跟141有一个区别就是要返回入环的第一个节点，那原版的快慢指针不能用了，所以我第一反应是哈希。因为快慢指针快指针和慢指针指向同一个元素时可能不是环的的第一个节点。
要使用快慢指针的话，如果存在环，快慢指针会相遇。这时候让快指针不动，慢指针走一圈到快指针的位置，这时候可以算出环的长度。然后再使用两个指针从头走，其中一个先走环的长度，然后两个指针一步步走，相遇节点就是入环的第一个节点。
### 解法一：哈希
```java
import java.util.HashSet;
public class Solution {
    public ListNode detectCycle(ListNode head) {
		if(head==null || head.next==null)
			return null;
        Set<ListNode> set = new HashSet<>();
        while(head!=null){
            if(!set.add(head))
                return head;
            head = head.next;
        }
        return null;
    }
}
```
时间复杂度O(N),空间复杂度O(N)
### 解法二：快慢指针
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null || head.next == null)
            return null;
        int cycleCount = 0;
        ListNode fast = head.next;
        ListNode slow = head;
        while(fast!=slow){
            if(fast==null || fast.next==null){
                return null;
            }
            fast = fast.next.next;
            slow = slow.next;
        }
        do{
            slow = slow.next;
            cycleCount++;
        }while(fast!=slow);
        ListNode p = head;
        ListNode q = head;
        while(cycleCount>0){
            q = q.next;
            cycleCount--;
        }
        while(p!=q){
            p = p.next;
            q = q.next;
        }
        return p;
    }
}
```
时间复杂度O(N),空间复杂度O(1)